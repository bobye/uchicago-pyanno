

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>models Module &mdash; pyanno 2.0dev documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.0dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyanno 2.0dev documentation" href="index.html" />
    <link rel="up" title="pyanno Package" href="pyanno.html" />
    <link rel="next" title="annotations Module" href="pyanno.annotations.html" />
    <link rel="prev" title="pyanno Package" href="pyanno.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyanno.annotations.html" title="annotations Module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pyanno.html" title="pyanno Package"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyanno 2.0dev documentation</a> &raquo;</li>
          <li><a href="modules.html" >Project Modules</a> &raquo;</li>
          <li><a href="pyanno.html" accesskey="U">pyanno Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="models-module">
<h1>models Module<a class="headerlink" href="#models-module" title="Permalink to this headline">¶</a></h1>
<p>These classes are implementations of statistical models of annotations. They
are available through the <tt class="xref py py-mod docutils literal"><span class="pre">pyanno.models</span></tt> namespace, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyanno.models</span>
<span class="c"># create a new instance of model B, for 4 label classes and 6 annotators</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pyanno</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ModelB</span><span class="o">.</span><span class="n">create_initial_state</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="module-pyanno.modelB">
<span id="modelb-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">modelB</span></tt> Module<a class="headerlink" href="#module-pyanno.modelB" title="Permalink to this headline">¶</a></h2>
<p>This module defines the class ModelB, a Bayesian generalization
of the model proposed in (Dawid et al., 1979).</p>
<p><strong>Reference:</strong></p>
<ul class="simple">
<li>Dawid, A. P. and A. M. Skene. 1979.  Maximum likelihood
estimation of observer error-rates using the EM algorithm.  Applied
Statistics, 28(1):20&#8211;28.</li>
</ul>
<dl class="class">
<dt id="pyanno.modelB.ModelB">
<em class="property">class </em><tt class="descclassname">pyanno.modelB.</tt><tt class="descname">ModelB</tt><big>(</big><em>nclasses</em>, <em>nannotators</em>, <em>pi</em>, <em>theta</em>, <em>alpha=None</em>, <em>beta=None</em>, <em>**traits</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyanno.html#pyanno.abstract_model.AbstractModel" title="pyanno.abstract_model.AbstractModel"><tt class="xref py py-class docutils literal"><span class="pre">pyanno.abstract_model.AbstractModel</span></tt></a></p>
<p>Bayesian generalization of the model proposed in (Dawid et al., 1979).</p>
<p>Model B is a hierarchical generative model over annotations. The model
assumes the existence of &#8220;true&#8221; underlying labels for each item,
which are drawn from a categorical distribution,
<img class="math" src="_images/math/f2ca003a7da0de4994b4733e203b74ff52d42553.png" alt="\pi"/>. Annotators report this labels with some noise, depending
on their accuracy, <img class="math" src="_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png" alt="\theta"/>.</p>
<p>The model parameters are:</p>
<blockquote>
<div><ul class="simple">
<li><cite>pi[k]</cite> is the probability of label k</li>
<li><cite>theta[j,k,k&#8217;]</cite> is the probability that annotator j reports label k&#8217;
for an item whose real label is k, i.e.
P( annotator j chooses k&#8217; | real label = k)</li>
</ul>
</div></blockquote>
<p>The parameters themselves are random variables with hyperparameters</p>
<blockquote>
<div><ul class="simple">
<li><cite>beta</cite> are the parameters of a Dirichlet distribution over <cite>pi</cite></li>
<li><cite>alpha[k,:]</cite> are the parameters of Dirichlet distributions over
<cite>theta[j,k,:]</cite></li>
</ul>
</div></blockquote>
<p>See the documentation for a more detailed description of the model.</p>
<p><strong>References:</strong></p>
<ul class="simple">
<li>Dawid, A. P. and A. M. Skene. 1979.  Maximum likelihood
estimation of observer error-rates using the EM algorithm.  Applied
Statistics, 28(1):20&#8211;28.</li>
<li>Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &#8220;How to get the most
from your curation effort&#8221;, PLoS Computational Biology, 5(5).</li>
</ul>
<dl class="method">
<dt id="pyanno.modelB.ModelB.annotator_accuracy">
<tt class="descname">annotator_accuracy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.annotator_accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.annotator_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the accuracy of each annotator.</p>
<p>Compute a summary of the a-priori accuracy of each annotator, i.e.,
P( annotator j is correct ). This can be computed from the parameters
theta and pi, as</p>
<p>P( annotator j is correct )
= sum_k P( annotator j reports k | label is k ) P( label is k )
= sum_k theta[j,k,k] * pi[k]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>accuracy</strong> (ndarray, shape = (n_annotators, )) - accuracy[j] = P( annotator j is correct )</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.annotator_accuracy_samples">
<tt class="descname">annotator_accuracy_samples</tt><big>(</big><em>theta_samples</em>, <em>pi_samples</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.annotator_accuracy_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.annotator_accuracy_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return samples from the accuracy of each annotator.</p>
<p>Given samples from the posterior of accuracy parameters theta
(see <a href="#id1"><span class="problematic" id="id2">:method:`sample_posterior_over_accuracy`</span></a>), compute
samples from the posterior distribution of the annotator accuracy,
i.e.,</p>
<p>P( annotator j is correct | annotations).</p>
<p>See also <a href="#id3"><span class="problematic" id="id4">:method:`sample_posterior_over_accuracy`</span></a>,
<a href="#id5"><span class="problematic" id="id6">:method:`annotator_accuracy`</span></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>accuracy</strong> (ndarray, shape = (n_annotators, )) - accuracy[j] = P( annotator j is correct )</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pyanno.modelB.ModelB.create_initial_state">
<em class="property">static </em><tt class="descname">create_initial_state</tt><big>(</big><em>nclasses</em>, <em>nannotators</em>, <em>alpha=None</em>, <em>beta=None</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.create_initial_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.create_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method returning a model with random initial parameters.</p>
<p>It is often more convenient to use this factory method over the
constructor, as one does not need to specify the initial model
parameters.</p>
<p>The parameters theta and pi, controlling accuracy and prevalence,
are initialized at random from the prior alpha and beta:</p>
<p><img class="math" src="_images/math/89eb5c5b9c8f1b6450ca12bb52b9376df9d770d3.png" alt="\theta_j^k \sim \mathrm{Dirichlet}(\mathbf{\alpha_k})"/></p>
<p><img class="math" src="_images/math/a38435656269269650b418db6503d4c9365debfe.png" alt="\pi \sim \mathrm{Dirichlet}(\mathbf{\beta})"/></p>
<p>If not defined, the prior parameters alpha ad beta are defined as
described below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nclasses</strong> (<em>int</em>) &#8211; Number of label classes</li>
<li><strong>nannotators</strong> (<em>int</em>) &#8211; Number of annotators</li>
<li><strong>alpha</strong> (<em>ndarray</em>) &#8211; Parameters of Dirichlet prior over annotator choices
Default value is a band matrix that peaks at the correct
annotation, with a value of 16 and decays to 1 with diverging
classes. This prior is ideal for ordinal annotations.</li>
<li><strong>beta</strong> (<em>ndarray</em>) &#8211; Parameters of Dirichlet prior over model categories
Default value for beta[i] is 1.0 .</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>model</strong> (<a class="reference internal" href="#pyanno.modelB.ModelB" title="pyanno.modelB.ModelB"><tt class="xref py py-class docutils literal"><span class="pre">ModelB</span></tt></a>) - Instance of ModelB</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pyanno.modelB.ModelB.default_alpha">
<em class="property">static </em><tt class="descname">default_alpha</tt><big>(</big><em>nclasses</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.default_alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.default_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pyanno.modelB.ModelB.default_beta">
<em class="property">static </em><tt class="descname">default_beta</tt><big>(</big><em>nclasses</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.default_beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.default_beta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.generate_annotations">
<tt class="descname">generate_annotations</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.generate_annotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.generate_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random annotation set from the model.</p>
<p>Sample a random set of annotations from the probability distribution
defined the current model parameters:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Label classes are generated from the prior distribution, pi</li>
<li>Annotations are generated from the conditional distribution of
annotations given classes, theta</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nitems</strong> (<em>int</em>) &#8211; Number of items to sample</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.generate_annotations_from_labels">
<tt class="descname">generate_annotations_from_labels</tt><big>(</big><em>labels</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.generate_annotations_from_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.generate_annotations_from_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random annotations from the model, given labels</p>
<p>The method samples random annotations from the conditional probability
distribution of annotations, <img class="math" src="_images/math/391d16aa9be108ec679aeaf14a6f3b532f4fef19.png" alt="x_i^j"/>
given labels, <img class="math" src="_images/math/6e6ceb79ebc4bf613298e0144eae25dd73de9be3.png" alt="y_i"/>:</p>
<p><img class="math" src="_images/math/f5fbb69852d37c1ee3d0a6b0b4f59e9663f16470.png" alt="x_i^j \sim \mathrm{Categorical}(\mathbf{\theta_j^{y_i}})"/></p>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items,), dtype = int</span></dt>
<dd>Set of &#8220;true&#8221; labels</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.generate_labels">
<tt class="descname">generate_labels</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.generate_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random labels from the model.</p>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.infer_labels">
<tt class="descname">infer_labels</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.infer_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.infer_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer posterior distribution over label classes.</p>
<p>Compute the posterior distribution over label classes given observed
annotations, <img class="math" src="_images/math/3486cefe86b6062b8244d973dd240d6e23913353.png" alt="P( \mathbf{y} | \mathbf{x}, \theta, \omega)"/>.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>posterior</strong> (ndarray, shape = (n_items, n_classes)) - posterior[i,k] is the posterior probability of class k given the annotation observed in item i.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.log_likelihood">
<tt class="descname">log_likelihood</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log likelihood of a set of annotations given the model.</p>
<p>Returns log P(annotations | current model parameters).</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>log_lhood</strong> (float) - log likelihood of <cite>annotations</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.map">
<tt class="descname">map</tt><big>(</big><em>annotations</em>, <em>epsilon=1e-05</em>, <em>init_accuracy=0.6</em>, <em>max_epochs=1000</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum a posteriori (MAP) estimation of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">pi</span></tt> from a set of
observed annotations using maximum a posteriori estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>epsilon <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The estimation is interrupted when the objective function has
changed less than <cite>epsilon</cite> on average over the last 10 iterations</dd>
<dt>initial_accuracy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Initialize the accuracy parameters, <cite>theta</cite> to a set of
distributions where theta[j,k,k&#8217;] = initial_accuracy if k==k&#8217;,
and (1-initial_accuracy) / (n_classes - 1)</dd>
<dt>max_epoch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Interrupt the estimation after <cite>max_epoch</cite> iterations</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.mle">
<tt class="descname">mle</tt><big>(</big><em>annotations</em>, <em>epsilon=1e-05</em>, <em>init_accuracy=0.6</em>, <em>max_epochs=1000</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.mle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.mle" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum likelihood estimate (MLE) of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">pi</span></tt> from a set of
observed annotations using maximum likelihood estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>epsilon <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The estimation is interrupted when the objective function has
changed less than <cite>epsilon</cite> on average over the last 10 iterations</dd>
<dt>initial_accuracy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Initialize the accuracy parameters, <cite>theta</cite> to a set of
distributions where theta[j,k,k&#8217;] = initial_accuracy if k==k&#8217;,
and (1-initial_accuracy) / (n_classes - 1)</dd>
<dt>max_epoch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Interrupt the estimation after <cite>max_epoch</cite> iterations</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelB.ModelB.sample_posterior_over_accuracy">
<tt class="descname">sample_posterior_over_accuracy</tt><big>(</big><em>annotations</em>, <em>nsamples</em>, <em>burn_in_samples=0</em>, <em>thin_samples=1</em>, <em>return_all_samples=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelB.html#ModelB.sample_posterior_over_accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelB.ModelB.sample_posterior_over_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return samples from posterior distribution over theta given data.</p>
<p>Samples are drawn using Gibbs sampling, i.e., alternating between
sampling from the conditional distribution of theta given the
annotations and the label classes, and sampling from the conditional
distribution of the classes given theta and the annotations.</p>
<p>This results in a fast-mixing sampler, and so the parameters
controlling burn-in and thinning can be set to a small number
of samples.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples to draw from the posterior</dd>
<dt>burn_in_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Discard the first <cite>burn_in_samples</cite> during the initial burn-in
phase, where the Monte Carlo chain converges to the posterior</dd>
<dt>thin_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Only return one every <cite>thin_samples</cite> samples in order to reduce
the auto-correlation in the sampling chain. This is called
&#8220;thinning&#8221; in MCMC parlance.</dd>
<dt>return_all_samples <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, return not only samples for the parameters theta,
but also for the parameters pi, and the label classes, y.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>samples</strong> (ndarray, shape = (n_samples, n_annotators, nclasses, nclasses)) - samples[i,...] is one sample from the posterior distribution over the parameters <cite>theta</cite></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>(theta, pi, labels) <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ndarray</span></dt>
<dd>If the keyword argument <cite>return_all_samples</cite> is set to True,
return a tuple with the samples for the parameters theta,
the parameters pi, and the label classes, y</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyanno.modelBt">
<span id="modelbt-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">modelBt</span></tt> Module<a class="headerlink" href="#module-pyanno.modelBt" title="Permalink to this headline">¶</a></h2>
<p>This module defines model B-with-theta.</p>
<p>pyAnno includes another implementation of B-with-theta,
<a class="reference internal" href="#module-pyanno.modelBt_loopdesign" title="pyanno.modelBt_loopdesign"><tt class="xref py py-mod docutils literal"><span class="pre">pyanno.modelBt_loopdesign</span></tt></a>, which is optimized for a loop design
where each item is annotated by 3 out of 8 annotators.</p>
<dl class="class">
<dt id="pyanno.modelBt.ModelBt">
<em class="property">class </em><tt class="descclassname">pyanno.modelBt.</tt><tt class="descname">ModelBt</tt><big>(</big><em>nclasses</em>, <em>nannotators</em>, <em>gamma</em>, <em>theta</em>, <em>**traits</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyanno.html#pyanno.abstract_model.AbstractModel" title="pyanno.abstract_model.AbstractModel"><tt class="xref py py-class docutils literal"><span class="pre">pyanno.abstract_model.AbstractModel</span></tt></a></p>
<p>Implementation of Model B-with-theta from (Rzhetsky et al., 2009).</p>
<p>The model assumes the existence of &#8220;true&#8221; underlying labels for each item,
which are drawn from a categorical distribution, gamma. Annotators report
this labels with some noise, according to their accuracy, theta.</p>
<p>This model is closely related to <tt class="xref py py-class docutils literal"><span class="pre">ModelB</span></tt>, but, crucially,
the noise distribution is described by a small number of parameters (one
per annotator), which makes their estimation efficient and less sensitive
to local optima.</p>
<p>The model parameters are:</p>
<ul class="simple">
<li><cite>gamma[k]</cite> is the probability of label k</li>
<li><cite>theta[j]</cite> parametrizes the probability that annotator <cite>j</cite> reports label</li>
</ul>
<p><cite>k&#8217;</cite> given ground truth, <cite>k</cite>. More specifically,
<cite>P( annotator j chooses k&#8217; | real label = k)</cite> is
<cite>theta[j]</cite> for k&#8217; = k, or <cite>(1 - theta[j]) / sum(theta)</cite> if <a href="#id7"><span class="problematic" id="id8">`</span></a>k&#8217; != k <a href="#id9"><span class="problematic" id="id10">`</span></a>.</p>
<p>See the documentation for a more detailed description of the model.</p>
<p>For a version of this model optimized for the loop design described
in (Rzhetsky et al., 2009), see <tt class="xref py py-class docutils literal"><span class="pre">ModelBtLoopDesign</span></tt>.</p>
<p><strong>Reference</strong></p>
<ul class="simple">
<li>Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &#8220;How to get the most
from your curation effort&#8221;, PLoS Computational Biology, 5(5).</li>
</ul>
<dl class="staticmethod">
<dt id="pyanno.modelBt.ModelBt.create_initial_state">
<em class="property">static </em><tt class="descname">create_initial_state</tt><big>(</big><em>nclasses</em>, <em>nannotators</em>, <em>gamma=None</em>, <em>theta=None</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.create_initial_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.create_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method returning a model with random initial parameters.</p>
<p>It is often more convenient to use this factory method over the
constructor, as one does not need to specify the initial model
parameters.</p>
<p>The parameters theta and gamma, controlling accuracy and prevalence,
are initialized at random as follows:</p>
<p><img class="math" src="_images/math/7f234c409ac81a31d0dac1c7c28322b5cf345337.png" alt="\theta_j \sim \mathrm{Uniform}(0.6, 0.95)"/></p>
<p><img class="math" src="_images/math/6b8a34f432fdad8e2b538964bd6d514527d6ae02.png" alt="\gamma \sim \mathrm{Dirichlet}(2.0)"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nclasses</strong> (<em>int</em>) &#8211; Number of label classes</li>
<li><strong>nannotators</strong> (<em>int</em>) &#8211; Number of annotators</li>
<li><strong>gamma</strong> (<em>ndarray, shape = (n_classes, )</em>) &#8211; gamma[k] is the prior probability of label class k</li>
<li><strong>theta</strong> (<em>ndarray, shape = (n_annotators, )</em>) &#8211; theta[j] parametrizes the accuracy of annotator j. Specifically,
<cite>P( annotator j chooses k&#8217; | real label = k)</cite> is
<cite>theta[j]</cite> for k&#8217; = k, or <cite>(1 - theta[j]) / sum(theta)</cite>
if <a href="#id11"><span class="problematic" id="id12">`</span></a>k&#8217; != k <a href="#id13"><span class="problematic" id="id14">`</span></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>model</strong> (<a class="reference internal" href="#pyanno.modelBt.ModelBt" title="pyanno.modelBt.ModelBt"><tt class="xref py py-class docutils literal"><span class="pre">ModelBt</span></tt></a>) - Instance of ModelBt</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.generate_annotations">
<tt class="descname">generate_annotations</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.generate_annotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.generate_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random annotation set from the model.</p>
<p>Sample a random set of annotations from the probability distribution
defined the current model parameters:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Label classes are generated from the prior distribution, pi</li>
<li>Annotations are generated from the conditional distribution of
annotations given classes, parametrized by theta</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nitems</strong> (<em>int</em>) &#8211; Number of items to sample</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.generate_annotations_from_labels">
<tt class="descname">generate_annotations_from_labels</tt><big>(</big><em>labels</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.generate_annotations_from_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.generate_annotations_from_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random annotations from the model, given labels</p>
<p>The method samples random annotations from the conditional probability
distribution of annotations, <img class="math" src="_images/math/391d16aa9be108ec679aeaf14a6f3b532f4fef19.png" alt="x_i^j"/>
given labels, <img class="math" src="_images/math/6e6ceb79ebc4bf613298e0144eae25dd73de9be3.png" alt="y_i"/>.</p>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items,), dtype = int</span></dt>
<dd>Set of &#8220;true&#8221; labels</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.generate_labels">
<tt class="descname">generate_labels</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.generate_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random labels from the model.</p>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.infer_labels">
<tt class="descname">infer_labels</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.infer_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.infer_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer posterior distribution over label classes.</p>
<p>Compute the posterior distribution over label classes given observed
annotations, <img class="math" src="_images/math/3486cefe86b6062b8244d973dd240d6e23913353.png" alt="P( \mathbf{y} | \mathbf{x}, \theta, \omega)"/>.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>posterior</strong> (ndarray, shape = (n_items, n_classes)) - posterior[i,k] is the posterior probability of class k given the annotation observed in item i.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.log_likelihood">
<tt class="descname">log_likelihood</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log likelihood of a set of annotations given the model.</p>
<p>Returns <img class="math" src="_images/math/c815e2772f6be8bc0b9386b6c9a9d95fd2505181.png" alt="\log P(\mathbf{x} | \gamma, \theta)"/>,
where <img class="math" src="_images/math/5f61118f2ae912f86e683687c005145b5eb54aec.png" alt="\mathbf{x}"/> is the array of annotations.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>log_lhood</strong> (float) - log likelihood of <cite>annotations</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.map">
<tt class="descname">map</tt><big>(</big><em>annotations</em>, <em>estimate_gamma=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum a posteriori (MAP) estimate of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> from a set of
observed annotations using maximum a posteriori estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>estimate_gamma <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> is left unchanged.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.mle">
<tt class="descname">mle</tt><big>(</big><em>annotations</em>, <em>estimate_gamma=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.mle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.mle" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum likelihood estimate (MLE) of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> from a set of
observed annotations using maximum likelihood estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>estimate_gamma <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> is left unchanged.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt.ModelBt.sample_posterior_over_accuracy">
<tt class="descname">sample_posterior_over_accuracy</tt><big>(</big><em>annotations</em>, <em>nsamples</em>, <em>burn_in_samples=100</em>, <em>thin_samples=5</em>, <em>target_rejection_rate=0.3</em>, <em>rejection_rate_tolerance=0.2</em>, <em>step_optimization_nsamples=500</em>, <em>adjust_step_every=100</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt.html#ModelBt.sample_posterior_over_accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt.ModelBt.sample_posterior_over_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return samples from posterior distribution over theta given data.</p>
<p>Samples are drawn using a variant of a Metropolis-Hasting Markov Chain
Monte Carlo (MCMC) algorithm. Sampling proceeds in two phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><em>step size estimation phase</em>: first, the step size in the
MCMC algorithm is adjusted to achieve a given rejection rate.</li>
<li><em>sampling phase</em>: second, samples are collected using the
step size from phase 1.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples to return (i.e., burn-in and thinning samples
are not included)</dd>
<dt>burn_in_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Discard the first <cite>burn_in_samples</cite> during the initial burn-in
phase, where the Monte Carlo chain converges to the posterior</dd>
<dt>thin_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Only return one every <cite>thin_samples</cite> samples in order to reduce
the auto-correlation in the sampling chain. This is called
&#8220;thinning&#8221; in MCMC parlance.</dd>
<dt>target_rejection_rate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>target rejection rate for the step size estimation phase</dd>
<dt>rejection_rate_tolerance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>the step size estimation phase is ended when the rejection rate for
all parameters is within <cite>rejection_rate_tolerance</cite> from
<cite>target_rejection_rate</cite></dd>
<dt>step_optimization_nsamples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples to draw in the step size estimation phase</dd>
<dt>adjust_step_every <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples after which the step size is adjusted during
the step size estimation pahse</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>samples</strong> (ndarray, shape = (n_samples, n_annotators)) - samples[i,:] is one sample from the posterior distribution over the parameters <cite>theta</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyanno.modelBt_loopdesign">
<span id="modelbt-loopdesign-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">modelBt_loopdesign</span></tt> Module<a class="headerlink" href="#module-pyanno.modelBt_loopdesign" title="Permalink to this headline">¶</a></h2>
<p>This module defines model B-with-theta, optimized for a loop design.</p>
<p>The implementation assumes that there are a total or 8 annotators. Each item is
annotated by a triplet of annotators, according to the loop design described
in Rzhetsky et al., 2009.</p>
<p>E.g., for 16 items the loop design looks like this (<cite>A</cite> indicates a label,
<cite>*</cite> indicates a missing value):</p>
<div class="highlight-python"><pre>A A A * * * * *
A A A * * * * *
* A A A * * * *
* A A A * * * *
* * A A A * * *
* * A A A * * *
* * * A A A * *
* * * A A A * *
* * * * A A A *
* * * * A A A *
* * * * * A A A
* * * * * A A A
A * * * * * A A
A * * * * * A A
A A * * * * * A
A A * * * * * A</pre>
</div>
<dl class="class">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign">
<em class="property">class </em><tt class="descclassname">pyanno.modelBt_loopdesign.</tt><tt class="descname">ModelBtLoopDesign</tt><big>(</big><em>nclasses</em>, <em>gamma</em>, <em>theta</em>, <em>**traits</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyanno.html#pyanno.abstract_model.AbstractModel" title="pyanno.abstract_model.AbstractModel"><tt class="xref py py-class docutils literal"><span class="pre">pyanno.abstract_model.AbstractModel</span></tt></a></p>
<p>Implementation of Model B-with-theta from (Rzhetsky et al., 2009).</p>
<p>The model assumes the existence of &#8220;true&#8221; underlying labels for each item,
which are drawn from a categorical distribution, gamma. Annotators report
this labels with some noise.</p>
<p>This model is closely related to <tt class="xref py py-class docutils literal"><span class="pre">ModelB</span></tt>, but, crucially,
the noise distribution is described by a small number of parameters (one
per annotator), which makes their estimation efficient and less sensitive
to local optima.</p>
<p>The model parameters are:</p>
<ul class="simple">
<li>gamma[k] is the probability of label k</li>
<li>theta[j] parametrized the probability that annotator j reports label k&#8217;.
More specifically, P( annotator j chooses k&#8217; | real label = k) is
theta[j] for k&#8217; = k, or (1 - theta[j]) / sum(theta) if k&#8217; != k .</li>
</ul>
<p>This implementation is optimized for he loop design introduced in
(Rzhetsky et al., 2009), which assumes that each item is annotated by 3
out of 8 annotators. For a more general implementation, see
<tt class="xref py py-class docutils literal"><span class="pre">ModelBt</span></tt></p>
<p>See the documentation for a more detailed description of the model.</p>
<p><strong>Reference</strong></p>
<ul class="simple">
<li>Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &#8220;How to get the most
from your curation effort&#8221;, PLoS Computational Biology, 5(5).</li>
</ul>
<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.are_annotations_compatible">
<tt class="descname">are_annotations_compatible</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.are_annotations_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.are_annotations_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the annotations are compatible with the models&#8217; parameters.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.create_initial_state">
<em class="property">static </em><tt class="descname">create_initial_state</tt><big>(</big><em>nclasses</em>, <em>gamma=None</em>, <em>theta=None</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.create_initial_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.create_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method returning a model with random initial parameters.</p>
<p>It is often more convenient to use this factory method over the
constructor, as one does not need to specify the initial model
parameters.</p>
<p>The parameters theta and gamma, controlling accuracy and prevalence,
are initialized at random as follows:</p>
<p><img class="math" src="_images/math/7f234c409ac81a31d0dac1c7c28322b5cf345337.png" alt="\theta_j \sim \mathrm{Uniform}(0.6, 0.95)"/></p>
<p><img class="math" src="_images/math/6b8a34f432fdad8e2b538964bd6d514527d6ae02.png" alt="\gamma \sim \mathrm{Dirichlet}(2.0)"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nclasses</strong> (<em>int</em>) &#8211; number of categories</li>
<li><strong>gamma</strong> (<em>nparray</em>) &#8211; An array of floats with size that holds the probability of each
annotation value. Default is None</li>
<li><strong>theta</strong> (<em>nparray</em>) &#8211; An array of floats that the parameters of P( v_i | psi ) (one for
each annotator)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>model</strong> (<a class="reference internal" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign" title="pyanno.modelBt_loopdesign.ModelBtLoopDesign"><tt class="xref py py-class docutils literal"><span class="pre">ModelBtLoopDesign</span></tt></a>) - Instance of ModelBtLoopDesign</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_annotations">
<tt class="descname">generate_annotations</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.generate_annotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random annotation set from the model.</p>
<p>Sample a random set of annotations from the probability distribution
defined the current model parameters:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Label classes are generated from the prior distribution, pi</li>
<li>Annotations are generated from the conditional distribution of
annotations given classes, parametrized by theta</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nitems</strong> (<em>int</em>) &#8211; Number of items to sample</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_annotations_from_labels">
<tt class="descname">generate_annotations_from_labels</tt><big>(</big><em>labels</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.generate_annotations_from_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_annotations_from_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random annotations from the model, given labels</p>
<p>The method samples random annotations from the conditional probability
distribution of annotations, <img class="math" src="_images/math/391d16aa9be108ec679aeaf14a6f3b532f4fef19.png" alt="x_i^j"/>
given labels, <img class="math" src="_images/math/6e6ceb79ebc4bf613298e0144eae25dd73de9be3.png" alt="y_i"/>.</p>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items,), dtype = int</span></dt>
<dd>Set of &#8220;true&#8221; labels</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_labels">
<tt class="descname">generate_labels</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.generate_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random labels from the model.</p>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.infer_labels">
<tt class="descname">infer_labels</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.infer_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.infer_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer posterior distribution over label classes.</p>
<p>Compute the posterior distribution over label classes given observed
annotations, <img class="math" src="_images/math/3486cefe86b6062b8244d973dd240d6e23913353.png" alt="P( \mathbf{y} | \mathbf{x}, \theta, \omega)"/>.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>posterior</strong> (ndarray, shape = (n_items, n_classes)) - posterior[i,k] is the posterior probability of class k given the annotation observed in item i.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.log_likelihood">
<tt class="descname">log_likelihood</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log likelihood of a set of annotations given the model.</p>
<p>Returns <img class="math" src="_images/math/c815e2772f6be8bc0b9386b6c9a9d95fd2505181.png" alt="\log P(\mathbf{x} | \gamma, \theta)"/>,
where <img class="math" src="_images/math/5f61118f2ae912f86e683687c005145b5eb54aec.png" alt="\mathbf{x}"/> is the array of annotations.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>log_lhood</strong> (float) - log likelihood of <cite>annotations</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.map">
<tt class="descname">map</tt><big>(</big><em>annotations</em>, <em>estimate_gamma=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum a posteriori (MAP) estimate of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> from a set of
observed annotations using maximum a posteriori estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>estimate_gamma <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> is left unchanged.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.mle">
<tt class="descname">mle</tt><big>(</big><em>annotations</em>, <em>estimate_gamma=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.mle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.mle" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum likelihood estimate (MLE) of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> from a set of
observed annotations using maximum likelihood estimation.</p>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>estimate_gamma <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">gamma</span></tt> is left unchanged.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelBt_loopdesign.ModelBtLoopDesign.sample_posterior_over_accuracy">
<tt class="descname">sample_posterior_over_accuracy</tt><big>(</big><em>annotations</em>, <em>nsamples</em>, <em>burn_in_samples=100</em>, <em>thin_samples=5</em>, <em>target_rejection_rate=0.3</em>, <em>rejection_rate_tolerance=0.2</em>, <em>step_optimization_nsamples=500</em>, <em>adjust_step_every=100</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelBt_loopdesign.html#ModelBtLoopDesign.sample_posterior_over_accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelBt_loopdesign.ModelBtLoopDesign.sample_posterior_over_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return samples from posterior distribution over theta given data.</p>
<p>Samples are drawn using a variant of a Metropolis-Hasting Markov Chain
Monte Carlo (MCMC) algorithm. Sampling proceeds in two phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><em>step size estimation phase</em>: first, the step size in the
MCMC algorithm is adjusted to achieve a given rejection rate.</li>
<li><em>sampling phase</em>: second, samples are collected using the
step size from phase 1.</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = (n_items, n_annotators)</span></dt>
<dd>annotations[i,j] is the annotation of annotator j for item i</dd>
<dt>nsamples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of samples to return (i.e., burn-in and thinning samples
are not included)</dd>
<dt>burn_in_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Discard the first <cite>burn_in_samples</cite> during the initial burn-in
phase, where the Monte Carlo chain converges to the posterior</dd>
<dt>thin_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Only return one every <cite>thin_samples</cite> samples in order to reduce
the auto-correlation in the sampling chain. This is called
&#8220;thinning&#8221; in MCMC parlance.</dd>
<dt>target_rejection_rate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>target rejection rate for the step size estimation phase</dd>
<dt>rejection_rate_tolerance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>the step size estimation phase is ended when the rejection rate for
all parameters is within <cite>rejection_rate_tolerance</cite> from
<cite>target_rejection_rate</cite></dd>
<dt>step_optimization_nsamples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples to draw in the step size estimation phase</dd>
<dt>adjust_step_every <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples after which the step size is adjusted during
the step size estimation pahse</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>samples</strong> (ndarray, shape = (n_samples, n_annotators)) - samples[i,:] is one sample from the posterior distribution over the parameters <cite>theta</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyanno.modelA">
<span id="modela-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">modelA</span></tt> Module<a class="headerlink" href="#module-pyanno.modelA" title="Permalink to this headline">¶</a></h2>
<p>This module defines the class ModelA, an implementation of model A from
Rzhetsky et al., 2009.</p>
<p>The implementation assumes that there are a total or 8 annotators. Each item is
annotated by a triplet of annotators, according to the loop design described
in Rzhetsky et al., 2009.</p>
<p>E.g., for 16 items the loop design looks like this (<cite>A</cite> indicates a label,
<cite>*</cite> indicates a missing value):</p>
<div class="highlight-python"><pre>A A A * * * * *
A A A * * * * *
* A A A * * * *
* A A A * * * *
* * A A A * * *
* * A A A * * *
* * * A A A * *
* * * A A A * *
* * * * A A A *
* * * * A A A *
* * * * * A A A
* * * * * A A A
A * * * * * A A
A * * * * * A A
A A * * * * * A
A A * * * * * A</pre>
</div>
<p><strong>Reference</strong></p>
<ul class="simple">
<li>Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &#8220;How to get the most from
your curation effort&#8221;, PLoS Computational Biology, 5(5).</li>
</ul>
<dl class="class">
<dt id="pyanno.modelA.ModelA">
<em class="property">class </em><tt class="descclassname">pyanno.modelA.</tt><tt class="descname">ModelA</tt><big>(</big><em>nclasses</em>, <em>theta</em>, <em>omega</em>, <em>**traits</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyanno.html#pyanno.abstract_model.AbstractModel" title="pyanno.abstract_model.AbstractModel"><tt class="xref py py-class docutils literal"><span class="pre">pyanno.abstract_model.AbstractModel</span></tt></a></p>
<p>Implementation of Model A from (Rzhetsky et al., 2009).</p>
<p>The model defines a probability distribution over data annotations
in which each item is annotated by three users. The distributions is
described according to a three-steps generative model:</p>
<blockquote>
<div><p>1. First, the model independently generates correctness values for the
triplet of annotators (e.g., CCI where C=correct, I=incorrect)</p>
<p>2. Second, the model generates an agreement pattern compatible with
the correctness values (e.g., CII is compatible with the agreement
patterns &#8216;abb&#8217; and &#8216;abc&#8217;, where different letters correspond to
different annotations</p>
<p>3. Finally, the model generates actual observations compatible with
the agreement patterns</p>
</div></blockquote>
<p>The model has two main sets of parameters:</p>
<blockquote>
<div><ul class="simple">
<li>theta[j] is the probability that annotator j is correct</li>
<li>omega[k] is the probability of observing an annotation of class <cite>k</cite>
over all items and annotators</li>
</ul>
</div></blockquote>
<p>At the moment the implementation of the model assumes 1) a total of 8
annotators, and 2) each item is annotated by exactly 3 annotators.</p>
<p>See the documentation for a more detailed description of the model.</p>
<p><strong>Reference</strong></p>
<ul class="simple">
<li>Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &#8220;How to get the most
from your curation effort&#8221;, PLoS Computational Biology, 5(5).</li>
</ul>
<dl class="method">
<dt id="pyanno.modelA.ModelA.are_annotations_compatible">
<tt class="descname">are_annotations_compatible</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.are_annotations_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.are_annotations_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the annotations are compatible with the models&#8217; parameters.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pyanno.modelA.ModelA.create_initial_state">
<em class="property">static </em><tt class="descname">create_initial_state</tt><big>(</big><em>nclasses</em>, <em>theta=None</em>, <em>omega=None</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.create_initial_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.create_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory method to create a new model.</p>
<p>It is often more convenient to use this factory method over the
constructor, as one does not need to specify the initial model
parameters.</p>
<p>If not specified, the parameters theta are drawn from a uniform
distribution between 0.6 and 0.95 . The parameters omega are drawn
from a Dirichlet distribution with parameters 2.0 :</p>
<p><img class="math" src="_images/math/7f234c409ac81a31d0dac1c7c28322b5cf345337.png" alt="\theta_j \sim \mathrm{Uniform}(0.6, 0.95)"/></p>
<p><img class="math" src="_images/math/cf354175edf727176feecf976e43d62b387f8755.png" alt="\omega_k \sim \mathrm{Dirichlet}(2.0)"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nclasses</strong> (<em>int</em>) &#8211; number of possible annotation classes</li>
<li><strong>theta</strong> (<em>ndarray, shape = (n_annotators, )</em>) &#8211; theta[j] is the probability of annotator j being correct</li>
<li><strong>omega</strong> (<em>ndarray, shape = (n_classes, )</em>) &#8211; omega[k] is the probability of observing a label of class k</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.generate_annotations">
<tt class="descname">generate_annotations</tt><big>(</big><em>nitems</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.generate_annotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.generate_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate random annotations from the model.</p>
<p>The method samples random annotations from the probability
distribution defined by the model parameters:</p>
<blockquote>
<div><ol class="arabic simple">
<li>generate correct/incorrect labels for the three annotators,
according to the parameters <cite>theta</cite></li>
<li>generate agreement patterns (which annotator agrees which whom)
given the correctness information and the parameters <cite>alpha</cite></li>
<li>generate the annotations given the agreement patterns and the
parameters <cite>omega</cite></li>
</ol>
</div></blockquote>
<p>Note that, according to the model&#8217;s definition, only three annotators
per item return an annotation. Non-observed annotations have the
standard value of <a class="reference internal" href="pyanno.html#pyanno.util.MISSING_VALUE" title="pyanno.util.MISSING_VALUE"><tt class="xref py py-attr docutils literal"><span class="pre">MISSING_VALUE</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nitems</strong> (<em>int</em>) &#8211; number of annotations to draw from the model</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>annotations</strong> (ndarray, shape = (n_items, n_annotators)) - annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.infer_labels">
<tt class="descname">infer_labels</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.infer_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.infer_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer posterior distribution over label classes.</p>
<p>Compute the posterior distribution over label classes given observed
annotations, <img class="math" src="_images/math/3486cefe86b6062b8244d973dd240d6e23913353.png" alt="P( \mathbf{y} | \mathbf{x}, \theta, \omega)"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>annotations</strong> (<em>ndarray, shape = (n_items, n_annotators)</em>) &#8211; annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>posterior</strong> (ndarray, shape = (n_items, n_classes)) - posterior[i,k] is the posterior probability of class k given the annotation observed in item i.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.log_likelihood">
<tt class="descname">log_likelihood</tt><big>(</big><em>annotations</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log likelihood of a set of annotations given the model.</p>
<p>Returns <img class="math" src="_images/math/9739a7d38dd7197ac336b4d26557f430f2a6cfa0.png" alt="\log P(\mathbf{x} | \omega, \theta)"/>,
where <img class="math" src="_images/math/5f61118f2ae912f86e683687c005145b5eb54aec.png" alt="\mathbf{x}"/> is the array of annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>annotations</strong> (<em>ndarray, shape = (n_items, n_annotators)</em>) &#8211; annotations[i,j] is the annotation of annotator j for item i</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>log_lhood</strong> (float) - log likelihood of <cite>annotations</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.map">
<tt class="descname">map</tt><big>(</big><em>annotations</em>, <em>estimate_omega=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum a posteriori (MAP) estimate of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> from a set of
observed annotations using maximum a posteriori estimation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>annotations</strong> (<em>ndarray, shape = (n_items, n_annotators)</em>) &#8211; annotations[i,j] is the annotation of annotator j for item i</li>
<li><strong>estimate_omega</strong> (<em>bool</em>) &#8211; If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> is left unchanged.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.mle">
<tt class="descname">mle</tt><big>(</big><em>annotations</em>, <em>estimate_omega=True</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.mle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.mle" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes maximum likelihood estimate (MLE) of parameters.</p>
<p>Estimate the parameters <tt class="xref py py-attr docutils literal"><span class="pre">theta</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> from a set of
observed annotations using maximum likelihood estimation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>annotations</strong> (<em>ndarray, shape = (n_items, n_annotators)</em>) &#8211; annotations[i,j] is the annotation of annotator j for item i</li>
<li><strong>estimate_omega</strong> (<em>bool</em>) &#8211; If True, the parameters <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> are estimated by the empirical
class frequency. If False, <tt class="xref py py-attr docutils literal"><span class="pre">omega</span></tt> is left unchanged.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyanno.modelA.ModelA.sample_posterior_over_accuracy">
<tt class="descname">sample_posterior_over_accuracy</tt><big>(</big><em>annotations</em>, <em>nsamples</em>, <em>burn_in_samples=100</em>, <em>thin_samples=5</em>, <em>target_rejection_rate=0.3</em>, <em>rejection_rate_tolerance=0.2</em>, <em>step_optimization_nsamples=500</em>, <em>adjust_step_every=100</em><big>)</big><a class="reference internal" href="_modules/pyanno/modelA.html#ModelA.sample_posterior_over_accuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyanno.modelA.ModelA.sample_posterior_over_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return samples from posterior distribution over theta given data.</p>
<p>Samples are drawn using a variant of a Metropolis-Hasting Markov Chain
Monte Carlo (MCMC) algorithm. Sampling proceeds in two phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><em>step size estimation phase</em>: first, the step size in the
MCMC algorithm is adjusted to achieve a given rejection rate.</li>
<li><em>sampling phase</em>: second, samples are collected using the
step size from phase 1.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>annotations</strong> (<em>ndarray, shape = (n_items, n_annotators)</em>) &#8211; annotations[i,j] is the annotation of annotator j for item i</li>
<li><strong>nsamples</strong> (<em>int</em>) &#8211; number of samples to draw from the posterior</li>
<li><strong>burn_in_samples</strong> (<em>int</em>) &#8211; Discard the first <cite>burn_in_samples</cite> during the initial burn-in
phase, where the Monte Carlo chain converges to the posterior</li>
<li><strong>thin_samples</strong> (<em>int</em>) &#8211; Only return one every <cite>thin_samples</cite> samples in order to reduce
the auto-correlation in the sampling chain. This is called
&#8220;thinning&#8221; in MCMC parlance.</li>
<li><strong>target_rejection_rate</strong> (<em>float</em>) &#8211; target rejection rate for the step size estimation phase</li>
<li><strong>rejection_rate_tolerance</strong> (<em>float</em>) &#8211; the step size estimation phase is ended when the rejection rate for
all parameters is within <cite>rejection_rate_tolerance</cite> from
<cite>target_rejection_rate</cite></li>
<li><strong>step_optimization_nsamples</strong> (<em>int</em>) &#8211; number of samples to draw in the step size estimation phase</li>
<li><strong>adjust_step_every</strong> (<em>int</em>) &#8211; number of samples after which the step size is adjusted during
the step size estimation pahse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>samples</strong> (ndarray, shape = (n_samples, n_annotators)) - samples[i,:] is one sample from the posterior distribution over the parameters <cite>theta</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">models Module</a><ul>
<li><a class="reference internal" href="#module-pyanno.modelB"><tt class="docutils literal"><span class="pre">modelB</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyanno.modelBt"><tt class="docutils literal"><span class="pre">modelBt</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyanno.modelBt_loopdesign"><tt class="docutils literal"><span class="pre">modelBt_loopdesign</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyanno.modelA"><tt class="docutils literal"><span class="pre">modelA</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyanno.html"
                        title="previous chapter">pyanno Package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyanno.annotations.html"
                        title="next chapter">annotations Module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyanno.models.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyanno.annotations.html" title="annotations Module"
             >next</a> |</li>
        <li class="right" >
          <a href="pyanno.html" title="pyanno Package"
             >previous</a> |</li>
        <li><a href="index.html">pyanno 2.0dev documentation</a> &raquo;</li>
          <li><a href="modules.html" >Project Modules</a> &raquo;</li>
          <li><a href="pyanno.html" >pyanno Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Pietro Berkes, Bob Carpenter, Andrey Rzhetsky, James A. Evans.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>