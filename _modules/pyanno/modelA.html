

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyanno.modelA &mdash; pyanno 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="pyanno 2.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyanno 2.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyanno.modelA</h1><div class="highlight"><pre>
<span class="c"># Copyright (c) 2011, Enthought, Ltd.</span>
<span class="c"># Authors: Pietro Berkes &lt;pberkes@enthought.com&gt;, Andrey Rzhetsky</span>
<span class="c"># License: Modified BSD license (2-clause)</span>

<span class="sd">&quot;&quot;&quot;This module defines the class ModelA, an implementation of model A from</span>
<span class="sd">Rzhetsky et al., 2009.</span>

<span class="sd">The implementation assumes that there are a total or 8 annotators. Each item is</span>
<span class="sd">annotated by a triplet of annotators, according to the loop design described</span>
<span class="sd">in Rzhetsky et al., 2009.</span>

<span class="sd">E.g., for 16 items the loop design looks like this (`A` indicates a label,</span>
<span class="sd">`*` indicates a missing value): ::</span>

<span class="sd">    A A A * * * * *</span>
<span class="sd">    A A A * * * * *</span>
<span class="sd">    * A A A * * * *</span>
<span class="sd">    * A A A * * * *</span>
<span class="sd">    * * A A A * * *</span>
<span class="sd">    * * A A A * * *</span>
<span class="sd">    * * * A A A * *</span>
<span class="sd">    * * * A A A * *</span>
<span class="sd">    * * * * A A A *</span>
<span class="sd">    * * * * A A A *</span>
<span class="sd">    * * * * * A A A</span>
<span class="sd">    * * * * * A A A</span>
<span class="sd">    A * * * * * A A</span>
<span class="sd">    A * * * * * A A</span>
<span class="sd">    A A * * * * * A</span>
<span class="sd">    A A * * * * * A</span>

<span class="sd">**Reference**</span>

<span class="sd">* Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &quot;How to get the most from</span>
<span class="sd">  your curation effort&quot;, PLoS Computational Biology, 5(5).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">from</span> <span class="nn">traits.trait_numeric</span> <span class="kn">import</span> <span class="n">Array</span>
<span class="kn">from</span> <span class="nn">traits.trait_types</span> <span class="kn">import</span> <span class="n">Int</span>
<span class="kn">from</span> <span class="nn">pyanno.abstract_model</span> <span class="kn">import</span> <span class="n">AbstractModel</span>
<span class="kn">from</span> <span class="nn">pyanno.sampling</span> <span class="kn">import</span> <span class="n">optimize_step_size</span><span class="p">,</span> <span class="n">sample_distribution</span>
<span class="kn">from</span> <span class="nn">pyanno.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">compute_counts</span><span class="p">,</span> <span class="n">random_categorical</span><span class="p">,</span>
                         <span class="n">labels_frequency</span><span class="p">,</span> <span class="n">MISSING_VALUE</span><span class="p">,</span> <span class="n">SMALLEST_FLOAT</span><span class="p">,</span>
                         <span class="n">ninf_to_num</span> <span class="p">)</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="n">_compatibility_tables_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">_compatibility_tables</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a map from agreement indices to annotation patterns.</span>

<span class="sd">    The agreement indices are defined as in Table 3 of</span>
<span class="sd">    Rzhetsky et al., 2009, supplementary material:</span>
<span class="sd">    0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>

<span class="sd">    The dictionary maps an agreement index to an array of annotations</span>
<span class="sd">    compatible with the corresponding agreement pattern.</span>
<span class="sd">    For example, for nclasses=3 and index=1 the array contains these</span>
<span class="sd">    annotations:</span>
<span class="sd">    0 0 1</span>
<span class="sd">    0 0 2</span>
<span class="sd">    1 1 0</span>
<span class="sd">    1 1 2</span>
<span class="sd">    2 2 0</span>
<span class="sd">    2 2 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_compatibility_tables_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
        <span class="n">compatibility</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c"># aaa</span>
        <span class="k">for</span> <span class="n">psi1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="n">compatibility</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">psi1</span><span class="p">,</span> <span class="n">psi1</span><span class="p">,</span> <span class="n">psi1</span><span class="p">])</span>

        <span class="c"># aaA, aAa, Aaa</span>
        <span class="k">for</span> <span class="n">psi1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">psi2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">psi2</span> <span class="o">==</span> <span class="n">psi1</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">compatibility</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">psi1</span><span class="p">,</span> <span class="n">psi1</span><span class="p">,</span> <span class="n">psi2</span><span class="p">])</span>
                <span class="n">compatibility</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">psi1</span><span class="p">,</span> <span class="n">psi2</span><span class="p">,</span> <span class="n">psi1</span><span class="p">])</span>
                <span class="n">compatibility</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">psi2</span><span class="p">,</span> <span class="n">psi1</span><span class="p">,</span> <span class="n">psi1</span><span class="p">])</span>

        <span class="c"># Aa@</span>
        <span class="k">for</span> <span class="n">psi1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">psi2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">psi3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">psi1</span><span class="o">==</span><span class="n">psi2</span> <span class="ow">or</span> <span class="n">psi2</span><span class="o">==</span><span class="n">psi3</span> <span class="ow">or</span> <span class="n">psi1</span><span class="o">==</span><span class="n">psi3</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">compatibility</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">psi1</span><span class="p">,</span> <span class="n">psi2</span><span class="p">,</span> <span class="n">psi3</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">compatibility</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">compatibility</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">_compatibility_tables_cache</span><span class="p">[</span><span class="n">nclasses</span><span class="p">]</span> <span class="o">=</span> <span class="n">compatibility</span>

    <span class="k">return</span> <span class="n">_compatibility_tables_cache</span><span class="p">[</span><span class="n">nclasses</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_triplet_to_counts_index</span><span class="p">(</span><span class="n">triplet</span><span class="p">,</span> <span class="n">nclasses</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Map annotator triplets to data indices for the counts format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">triplet</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nclasses</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">nclasses</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="ModelA"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA">[docs]</a><span class="k">class</span> <span class="nc">ModelA</span><span class="p">(</span><span class="n">AbstractModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implementation of Model A from (Rzhetsky et al., 2009).</span>

<span class="sd">    The model defines a probability distribution over data annotations</span>
<span class="sd">    in which each item is annotated by three users. The distributions is</span>
<span class="sd">    described according to a three-steps generative model:</span>

<span class="sd">        1. First, the model independently generates correctness values for the</span>
<span class="sd">        triplet of annotators (e.g., CCI where C=correct, I=incorrect)</span>

<span class="sd">        2. Second, the model generates an agreement pattern compatible with</span>
<span class="sd">        the correctness values (e.g., CII is compatible with the agreement</span>
<span class="sd">        patterns &#39;abb&#39; and &#39;abc&#39;, where different letters correspond to</span>
<span class="sd">        different annotations</span>

<span class="sd">        3. Finally, the model generates actual observations compatible with</span>
<span class="sd">        the agreement patterns</span>

<span class="sd">    The model has two main sets of parameters:</span>

<span class="sd">        - theta[j] is the probability that annotator j is correct</span>

<span class="sd">        - omega[k] is the probability of observing an annotation of class `k`</span>
<span class="sd">          over all items and annotators</span>

<span class="sd">    At the moment the implementation of the model assumes 1) a total of 8</span>
<span class="sd">    annotators, and 2) each item is annotated by exactly 3 annotators.</span>

<span class="sd">    See the documentation for a more detailed description of the model.</span>

<span class="sd">    **Reference**</span>

<span class="sd">    * Rzhetsky A., Shatkay, H., and Wilbur, W.J. (2009). &quot;How to get the most</span>
<span class="sd">      from your curation effort&quot;, PLoS Computational Biology, 5(5).</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c">######## Model traits</span>

    <span class="c"># number of label classes</span>
    <span class="n">nclasses</span> <span class="o">=</span> <span class="n">Int</span>

    <span class="c"># number of annotators</span>
    <span class="n">nannotators</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

    <span class="c"># number of annotators rating each item in the loop design</span>
    <span class="n">nannotators_per_item</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c">#### Model parameters</span>

    <span class="c"># theta[j] is the probability that annotator j is correct</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>

    <span class="c"># omega[k] is the probability of observing label class k</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nclasses</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="o">**</span><span class="n">traits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of ModelA.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        nclasses : int</span>
<span class="sd">            Number of possible annotation classes</span>

<span class="sd">        theta : ndarray, shape = (n_annotators, )</span>
<span class="sd">            theta[j] is the probability of annotator j being correct</span>

<span class="sd">        omega : ndarray, shape = (n_classes, )</span>
<span class="sd">            omega[k] is the probability of observing a label of class k</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span> <span class="o">=</span> <span class="n">nclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ModelA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">traits</span><span class="p">)</span>


    <span class="c">##### Model and data generation methods ###################################</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ModelA.create_initial_state"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.create_initial_state">[docs]</a>    <span class="k">def</span> <span class="nf">create_initial_state</span><span class="p">(</span><span class="n">nclasses</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Factory method to create a new model.</span>

<span class="sd">        It is often more convenient to use this factory method over the</span>
<span class="sd">        constructor, as one does not need to specify the initial model</span>
<span class="sd">        parameters.</span>

<span class="sd">        If not specified, the parameters theta are drawn from a uniform</span>
<span class="sd">        distribution between 0.6 and 0.95 . The parameters omega are drawn</span>
<span class="sd">        from a Dirichlet distribution with parameters 2.0 :</span>

<span class="sd">        :math:`\\theta_j \sim \mathrm{Uniform}(0.6, 0.95)`</span>

<span class="sd">        :math:`\omega_k \sim \mathrm{Dirichlet}(2.0)`</span>


<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        nclasses : int</span>
<span class="sd">            number of possible annotation classes</span>

<span class="sd">        theta : ndarray, shape = (n_annotators, )</span>
<span class="sd">            theta[j] is the probability of annotator j being correct</span>

<span class="sd">        omega : ndarray, shape = (n_classes, )</span>
<span class="sd">            omega[k] is the probability of observing a label of class k</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nannotators</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">ModelA</span><span class="o">.</span><span class="n">_random_theta</span><span class="p">(</span><span class="n">nannotators</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">omega</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">ModelA</span><span class="o">.</span><span class="n">_random_omega</span><span class="p">(</span><span class="n">nclasses</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ModelA</span><span class="p">(</span><span class="n">nclasses</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>

</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_random_theta</span><span class="p">(</span><span class="n">nannotators</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
                                 <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">nannotators</span><span class="p">,))</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_random_omega</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nclasses</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">dirichlet</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>


<div class="viewcode-block" id="ModelA.generate_annotations"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.generate_annotations">[docs]</a>    <span class="k">def</span> <span class="nf">generate_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nitems</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate random annotations from the model.</span>

<span class="sd">        The method samples random annotations from the probability</span>
<span class="sd">        distribution defined by the model parameters:</span>

<span class="sd">            1) generate correct/incorrect labels for the three annotators,</span>
<span class="sd">               according to the parameters `theta`</span>

<span class="sd">            2) generate agreement patterns (which annotator agrees which whom)</span>
<span class="sd">               given the correctness information and the parameters `alpha`</span>

<span class="sd">            3) generate the annotations given the agreement patterns and the</span>
<span class="sd">               parameters `omega`</span>


<span class="sd">        Note that, according to the model&#39;s definition, only three annotators</span>
<span class="sd">        per item return an annotation. Non-observed annotations have the</span>
<span class="sd">        standard value of :attr:`~pyanno.util.MISSING_VALUE`.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        nitems : int</span>
<span class="sd">            number of annotations to draw from the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
        <span class="n">nannotators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span>
        <span class="n">nitems_per_loop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nitems</span><span class="p">)</span> <span class="o">/</span> <span class="n">nannotators</span><span class="p">)</span>

        <span class="n">annotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nitems</span><span class="p">,</span> <span class="n">nannotators</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">annotations</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">MISSING_VALUE</span><span class="p">)</span>

        <span class="c"># loop over annotator triplets (loop design)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nannotators</span><span class="p">):</span>
            <span class="n">triplet_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="n">nitems_per_loop</span>
            <span class="n">stop_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nitems</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nitems_per_loop</span><span class="p">)</span>
            <span class="n">nitems_this_loop</span> <span class="o">=</span> <span class="n">stop_idx</span> <span class="o">-</span> <span class="n">start_idx</span>

            <span class="c"># -- step 1: generate correct / incorrect labels</span>

            <span class="c"># parameters for this triplet</span>
            <span class="n">theta_triplet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">triplet_indices</span><span class="p">]</span>
            <span class="n">incorrect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_incorrectness</span><span class="p">(</span><span class="n">nitems_this_loop</span><span class="p">,</span>
                                                     <span class="n">theta_triplet</span><span class="p">)</span>

            <span class="c"># -- step 2: generate agreement patterns given correctness</span>
            <span class="c"># convert boolean correctness into combination indices</span>
            <span class="c"># (indices as in Table 3)</span>
            <span class="n">agreement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_agreement</span><span class="p">(</span><span class="n">incorrect</span><span class="p">)</span>

            <span class="c"># -- step 3: generate annotations</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">stop_idx</span><span class="p">,</span><span class="n">triplet_indices</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_generate_annotations</span><span class="p">(</span><span class="n">agreement</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">annotations</span>

</div>
    <span class="k">def</span> <span class="nf">_generate_incorrectness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">theta_triplet</span><span class="p">):</span>
        <span class="n">_rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nannotators_per_item</span><span class="p">)</span>
        <span class="n">incorrect</span> <span class="o">=</span> <span class="n">_rnd</span> <span class="o">&gt;=</span> <span class="n">theta_triplet</span>
        <span class="k">return</span> <span class="n">incorrect</span>


    <span class="k">def</span> <span class="nf">_generate_agreement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incorrect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return indices of agreement pattern given correctness pattern.</span>

<span class="sd">        The indices returned correspond to agreement patterns</span>
<span class="sd">        as in Table 3: 0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># create tensor A_ijk</span>
        <span class="c"># (cf. Table 3 in Rzhetsky et al., 2009, suppl. mat.)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_alpha</span><span class="p">()</span>
        <span class="n">agreement_tbl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="mf">1.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">1.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">1.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span>       <span class="mf">1.</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>       <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span>       <span class="mf">0.</span><span class="p">,</span>       <span class="mf">1.</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
             <span class="p">[</span><span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mf">1.</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()]])</span>

        <span class="c"># this array maps boolean correctness patterns (e.g., CCI) to</span>
        <span class="c"># indices in the agreement tensor, `agreement_tbl`</span>
        <span class="n">correctness_to_agreement_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

        <span class="c"># convert correctness pattern to index in the A_ijk tensor</span>
        <span class="n">correct_idx</span> <span class="o">=</span> <span class="n">correctness_to_agreement_idx</span><span class="p">[</span>
                      <span class="n">incorrect</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="n">incorrect</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">incorrect</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>

        <span class="c"># the indices stored in `agreement` correspond to agreement patterns</span>
        <span class="c"># as in Table 3: 0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>
        <span class="n">nitems_per_loop</span> <span class="o">=</span> <span class="n">incorrect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">agreement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nitems_per_loop</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nitems_per_loop</span><span class="p">):</span>
            <span class="c"># generate agreement pattern according to A_ijk</span>
            <span class="n">agreement</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_categorical</span><span class="p">(</span>
                <span class="n">agreement_tbl</span><span class="p">[</span><span class="n">correct_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">agreement</span>


    <span class="k">def</span> <span class="nf">_generate_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agreement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate triplet annotations given agreement pattern.&quot;&quot;&quot;</span>
        <span class="n">nitems_per_loop</span> <span class="o">=</span> <span class="n">agreement</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nitems_per_loop</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nitems_per_loop</span><span class="p">):</span>
            <span class="c"># get all compatible annotations</span>
            <span class="n">compatible</span> <span class="o">=</span> <span class="n">_compatibility_tables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)[</span><span class="n">agreement</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c"># compute probability of each possible annotation</span>
            <span class="n">distr</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">compatible</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">distr</span> <span class="o">/=</span> <span class="n">distr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c"># draw annotation</span>
            <span class="n">compatible_idx</span> <span class="o">=</span> <span class="n">random_categorical</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">compatible</span><span class="p">[</span><span class="n">compatible_idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">annotations</span>


    <span class="c">##### Parameters estimation methods #######################################</span>

<div class="viewcode-block" id="ModelA.mle"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.mle">[docs]</a>    <span class="k">def</span> <span class="nf">mle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">estimate_omega</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes maximum likelihood estimate (MLE) of parameters.</span>

<span class="sd">        Estimate the parameters :attr:`theta` and :attr:`omega` from a set of</span>
<span class="sd">        observed annotations using maximum likelihood estimation.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>

<span class="sd">        estimate_omega : bool</span>
<span class="sd">            If True, the parameters :attr:`omega` are estimated by the empirical</span>
<span class="sd">            class frequency. If False, :attr:`omega` is left unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_incompatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_wrap_lhood</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_likelihood_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_estimation</span><span class="p">(</span><span class="n">_wrap_lhood</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span>
                                   <span class="n">estimate_omega</span><span class="o">=</span><span class="n">estimate_omega</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ModelA.map"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">estimate_omega</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes maximum a posteriori (MAP) estimate of parameters.</span>

<span class="sd">        Estimate the parameters :attr:`theta` and :attr:`omega` from a set of</span>
<span class="sd">        observed annotations using maximum a posteriori estimation.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>

<span class="sd">        estimate_omega : bool</span>
<span class="sd">            If True, the parameters :attr:`omega` are estimated by the empirical</span>
<span class="sd">            class frequency. If False, :attr:`omega` is left unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_incompatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_wrap_lhood</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_likelihood_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_prior</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_estimation</span><span class="p">(</span><span class="n">_wrap_lhood</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span>
                                   <span class="n">estimate_omega</span><span class="o">=</span><span class="n">estimate_omega</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_parameter_estimation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span>
                              <span class="n">estimate_omega</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">compute_counts</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)</span>

        <span class="n">params_start</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_initial_parameters</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span>
                                                              <span class="n">estimate_omega</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Start parameters optimization...&#39;</span><span class="p">)</span>

        <span class="n">params_best</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span>
                                          <span class="n">params_start</span><span class="p">,</span>
                                          <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">counts</span><span class="p">,),</span>
                                          <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                                          <span class="n">disp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                          <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Parameters optimization finished&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">params_best</span>


    <span class="k">def</span> <span class="nf">_random_initial_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">estimate_omega</span><span class="p">):</span>
        <span class="c"># TODO duplication w/ ModelBtLoopDesign</span>
        <span class="k">if</span> <span class="n">estimate_omega</span><span class="p">:</span>
            <span class="c"># estimate omega from observed annotations</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">labels_frequency</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">ModelA</span><span class="o">.</span><span class="n">_random_theta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span>


    <span class="c">##### Model likelihood methods ############################################</span>

<div class="viewcode-block" id="ModelA.log_likelihood"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.log_likelihood">[docs]</a>    <span class="k">def</span> <span class="nf">log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the log likelihood of a set of annotations given the model.</span>

<span class="sd">        Returns :math:`\log P(\mathbf{x} | \omega, \\theta)`,</span>
<span class="sd">        where :math:`\mathbf{x}` is the array of annotations.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_lhood : float</span>
<span class="sd">            log likelihood of `annotations`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_incompatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">compute_counts</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_likelihood_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>

    <span class="c"># TODO code duplication with ModelBtLoopDesign -&gt; refactor</span></div>
    <span class="k">def</span> <span class="nf">_log_likelihood_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the log likelihood of annotations given the model.</span>

<span class="sd">        This method assumes the data is in counts format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: check if it&#39;s possible to replace these constraints with bounded optimization</span>
        <span class="c"># check bounds of parameters (for likelihood optimization)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># return np.inf</span>
            <span class="k">return</span> <span class="n">SMALLEST_FLOAT</span>

        <span class="c"># compute alpha and beta (they do not depend on theta)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_alpha</span><span class="p">()</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span>
        <span class="n">pattern_to_indices</span> <span class="o">=</span> <span class="n">_compatibility_tables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">pattern_to_indices</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>
            <span class="n">beta</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">beta</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span> <span class="o">/=</span> <span class="n">beta</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">llhood</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="c"># loop over the 8 combinations of annotators</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="c"># extract the theta parameters for this triplet</span>
            <span class="n">triplet_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span>
            <span class="n">triplet_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">theta_triplet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">triplet_indices</span><span class="p">]</span>

            <span class="c"># compute the likelihood for the triplet</span>
            <span class="n">llhood</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_likelihood_triplet</span><span class="p">(</span><span class="n">counts</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="n">theta_triplet</span><span class="p">,</span>
                                                   <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">llhood</span>


    <span class="k">def</span> <span class="nf">_log_likelihood_triplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts_triplet</span><span class="p">,</span> <span class="n">theta_triplet</span><span class="p">,</span>
                                <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the log likelihood of data for one triplet of annotators.</span>

<span class="sd">        Input:</span>
<span class="sd">        counts_triplet -- count data for one combination of annotators</span>
<span class="sd">        theta_triplet -- theta parameters of the current triplet</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nclasses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span>
        <span class="n">llhood</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c"># loop over all possible agreement patterns</span>
        <span class="c"># 0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>

        <span class="n">pattern_to_indices</span> <span class="o">=</span> <span class="n">_compatibility_tables</span><span class="p">(</span><span class="n">nclasses</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="c"># P( A_ijk | T_ijk ) * P( T_ijk )  , or &quot;alpha * theta triplet&quot;</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob_a_and_t</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">theta_triplet</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

            <span class="c"># P( V_ijk ! A_ijk) * P( A_ijk | T_ijk ) * P( T_ijk )</span>
            <span class="c">#   = P( V_ijk | A, T, model)</span>
            <span class="n">prob</span> <span class="o">*=</span> <span class="n">beta</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>

            <span class="c"># P( V_ijk | model ) = sum over A and T of conditional probability</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">pattern_to_indices</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>
            <span class="n">count_indices</span> <span class="o">=</span> <span class="n">_triplet_to_counts_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">nclasses</span><span class="p">)</span>
            <span class="n">log_prob</span> <span class="o">=</span> <span class="n">ninf_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">))</span>

            <span class="n">llhood</span> <span class="o">+=</span> <span class="p">(</span><span class="n">counts_triplet</span><span class="p">[</span><span class="n">count_indices</span><span class="p">]</span> <span class="o">*</span> <span class="n">log_prob</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">llhood</span>


    <span class="k">def</span> <span class="nf">_log_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute log probability of prior on the theta parameters.&quot;&quot;&quot;</span>
        <span class="n">log_prob</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">beta</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">log_prob</span><span class="p">):</span>
            <span class="n">log_prob</span> <span class="o">=</span> <span class="n">SMALLEST_FLOAT</span>
        <span class="k">return</span> <span class="n">log_prob</span>


    <span class="k">def</span> <span class="nf">_prob_a_and_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">theta_triplet</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="c"># TODO make more robust by taking logarithms earlier</span>
        <span class="c"># TODO could be vectorized some more using the A_ijk tensor</span>
        <span class="c"># 0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>

        <span class="c"># abbreviations</span>
        <span class="n">thetat</span> <span class="o">=</span> <span class="n">theta_triplet</span>
        <span class="n">not_thetat</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">theta_triplet</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pattern</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># aaa patterns</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">thetat</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">+</span> <span class="n">not_thetat</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">pattern</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># aaA patterns</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">pattern</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c"># aAa patterns</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">pattern</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c"># Aaa patterns</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">pattern</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c"># Aa@ pattern</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                      <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                      <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                      <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">not_thetat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                      <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">prob</span>


    <span class="c">##### Sampling posterior over parameters ##################################</span>

<div class="viewcode-block" id="ModelA.sample_posterior_over_accuracy"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.sample_posterior_over_accuracy">[docs]</a>    <span class="k">def</span> <span class="nf">sample_posterior_over_accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span>
                                       <span class="n">burn_in_samples</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                       <span class="n">thin_samples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                       <span class="n">target_rejection_rate</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                                       <span class="n">rejection_rate_tolerance</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                                       <span class="n">step_optimization_nsamples</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                                       <span class="n">adjust_step_every</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return samples from posterior distribution over theta given data.</span>

<span class="sd">        Samples are drawn using a variant of a Metropolis-Hasting Markov Chain</span>
<span class="sd">        Monte Carlo (MCMC) algorithm. Sampling proceeds in two phases:</span>

<span class="sd">            1) *step size estimation phase*: first, the step size in the</span>
<span class="sd">               MCMC algorithm is adjusted to achieve a given rejection rate.</span>

<span class="sd">            2) *sampling phase*: second, samples are collected using the</span>
<span class="sd">               step size from phase 1.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>

<span class="sd">        nsamples : int</span>
<span class="sd">            number of samples to draw from the posterior</span>

<span class="sd">        burn_in_samples : int</span>
<span class="sd">            Discard the first `burn_in_samples` during the initial burn-in</span>
<span class="sd">            phase, where the Monte Carlo chain converges to the posterior</span>

<span class="sd">        thin_samples : int</span>
<span class="sd">            Only return one every `thin_samples` samples in order to reduce</span>
<span class="sd">            the auto-correlation in the sampling chain. This is called</span>
<span class="sd">            &quot;thinning&quot; in MCMC parlance.</span>

<span class="sd">        target_rejection_rate : float</span>
<span class="sd">            target rejection rate for the step size estimation phase</span>

<span class="sd">        rejection_rate_tolerance : float</span>
<span class="sd">            the step size estimation phase is ended when the rejection rate for</span>
<span class="sd">            all parameters is within `rejection_rate_tolerance` from</span>
<span class="sd">            `target_rejection_rate`</span>

<span class="sd">        step_optimization_nsamples : int</span>
<span class="sd">            number of samples to draw in the step size estimation phase</span>

<span class="sd">        adjust_step_every : int</span>
<span class="sd">            number of samples after which the step size is adjusted during</span>
<span class="sd">            the step size estimation pahse</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        samples : ndarray, shape = (n_samples, n_annotators)</span>
<span class="sd">            samples[i,:] is one sample from the posterior distribution over the</span>
<span class="sd">            parameters `theta`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_incompatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_total_nsamples</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span>
                                                <span class="n">burn_in_samples</span><span class="p">,</span>
                                                <span class="n">thin_samples</span><span class="p">)</span>

        <span class="c"># optimize step size</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">compute_counts</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span><span class="p">)</span>

        <span class="c"># wrap log likelihood function to give it to optimize_step_size and</span>
        <span class="c"># sample_distribution</span>
        <span class="n">_llhood_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_likelihood_counts</span>
        <span class="n">_log_prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_prior</span>
        <span class="k">def</span> <span class="nf">_wrap_llhood</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="n">_llhood_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">+</span> <span class="n">_log_prior</span><span class="p">()</span>

        <span class="c"># TODO this save-reset is rather ugly, refactor: create copy of</span>
        <span class="c">#      model and sample over it</span>
        <span class="c"># save internal parameters to reset at the end of sampling</span>
        <span class="n">save_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># compute optimal step size for given target rejection rate</span>
            <span class="n">params_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">params_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span><span class="p">,))</span>
            <span class="n">params_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nannotators</span><span class="p">,))</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">optimize_step_size</span><span class="p">(</span><span class="n">_wrap_llhood</span><span class="p">,</span> <span class="n">params_start</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span>
                                <span class="n">params_lower</span><span class="p">,</span> <span class="n">params_upper</span><span class="p">,</span>
                                <span class="n">step_optimization_nsamples</span><span class="p">,</span>
                                <span class="n">adjust_step_every</span><span class="p">,</span>
                                <span class="n">target_rejection_rate</span><span class="p">,</span>
                                <span class="n">rejection_rate_tolerance</span><span class="p">)</span>

            <span class="c"># draw samples from posterior distribution over theta</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">sample_distribution</span><span class="p">(</span><span class="n">_wrap_llhood</span><span class="p">,</span> <span class="n">params_start</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span>
                                          <span class="n">step</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span>
                                          <span class="n">params_lower</span><span class="p">,</span> <span class="n">params_upper</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">burn_in_samples</span><span class="p">,</span>
                                              <span class="n">thin_samples</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># reset parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">save_params</span>


    <span class="c">##### Posterior distributions #############################################</span>

    <span class="c"># TODO ideally, one would infer the posterior over correctness (T_ijk)</span>
    <span class="c">#   first, and then return the probability of each value</span>
    <span class="c">#    def infer_correctness(self, annotations):</span>
    <span class="c">#        &quot;&quot;&quot;Infer posterior distribution over correctness patterns.&quot;&quot;&quot;</span>
    <span class="c">#        nitems = annotations.shape[0]</span>
    <span class="c">#        nclasses = self.nclasses</span>
    <span class="c">#</span>
    <span class="c">#        posterior = np.zeros((nitems, self.annotators_per_item**2))</span>
    <span class="c">#        alpha = self._compute_alpha()</span>
    <span class="c">#        for i, row in enumerate(annotations):</span>
    <span class="c">#            valid_idx = np.where(row &gt;= 0)</span>
    <span class="c">#            vijk = row[valid_idx]</span>
    <span class="c">#            tijk = self.theta[valid_idx]</span>
    <span class="c">#            p = self._compute_posterior_T_triplet(vijk, tijk, alpha)</span>
    <span class="c">#            posteriors[i, :] = p</span>
    <span class="c">#</span>
    <span class="c">#        return posteriors</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c">#    def _compute_posterior_T_triplet(self, v, t, alpha):</span>
    <span class="c">#        # switch over agreement pattern</span>
    <span class="c">#        # 0=aaa, 1=aaA, 2=aAa, 3=Aaa, 4=Aa@</span>
    <span class="c">#        if v[0] == v[1] == v[2]:  # aaa pattern</span>
    <span class="c">#            pass</span>

</div>
<div class="viewcode-block" id="ModelA.infer_labels"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.infer_labels">[docs]</a>    <span class="k">def</span> <span class="nf">infer_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Infer posterior distribution over label classes.</span>

<span class="sd">        Compute the posterior distribution over label classes given observed</span>
<span class="sd">        annotations, :math:`P( \mathbf{y} | \mathbf{x}, \\theta, \omega)`.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        annotations : ndarray, shape = (n_items, n_annotators)</span>
<span class="sd">            annotations[i,j] is the annotation of annotator j for item i</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        posterior : ndarray, shape = (n_items, n_classes)</span>
<span class="sd">            posterior[i,k] is the posterior probability of class k given the</span>
<span class="sd">            annotation observed in item i.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_incompatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

        <span class="n">nitems</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nclasses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span>

        <span class="n">posteriors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nitems</span><span class="p">,</span> <span class="n">nclasses</span><span class="p">))</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_alpha</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">vijk</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">tijk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_posterior_triplet</span><span class="p">(</span><span class="n">vijk</span><span class="p">,</span> <span class="n">tijk</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="n">posteriors</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">posteriors</span>

</div>
    <span class="k">def</span> <span class="nf">_compute_posterior_triplet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vijk</span><span class="p">,</span> <span class="n">tijk</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="n">nclasses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span>
        <span class="n">posteriors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nclasses</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="c">#-----------------------------------------------</span>
        <span class="c"># aaa</span>
        <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nclasses</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span>

        <span class="c">#-----------------------------------------------</span>
        <span class="c"># aaA</span>
        <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c"># a is correct</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># A is correct</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># neither</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nclasses</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span>

        <span class="c">#-----------------------------------------------</span>
        <span class="c"># aAa</span>
        <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c"># a is correct</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># A is correct</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># neither</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nclasses</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span>

        <span class="c">#-----------------------------------------------</span>
        <span class="c"># Aaa</span>
        <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c"># a is correct</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># A is correct</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*</span> <span class="n">x3</span><span class="p">)</span>

            <span class="c"># neither</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nclasses</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span>

        <span class="c">#-----------------------------------------------</span>
        <span class="c"># aAb</span>
        <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x4</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tijk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">summa1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="n">summa2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span>
                      <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">summa1</span> <span class="o">*</span> <span class="n">x4</span><span class="p">)</span>

            <span class="c"># a is correct</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">/</span> <span class="n">summa2</span>

            <span class="c"># A is correct</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">/</span> <span class="n">summa2</span>

            <span class="c"># b is correct</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">x3</span> <span class="o">/</span> <span class="n">summa2</span>

            <span class="c"># (a, A, b) are all incorrect</span>
            <span class="n">p4</span> <span class="o">=</span> <span class="p">(</span><span class="n">summa1</span> <span class="o">*</span> <span class="n">x4</span> <span class="o">/</span> <span class="n">summa2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nclasses</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="k">elif</span> <span class="n">vijk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">posteriors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p4</span>

        <span class="c"># check posteriors: non-negative, sum to 1</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">posteriors</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span>
        <span class="k">assert</span> <span class="n">posteriors</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.</span>

        <span class="k">return</span> <span class="n">posteriors</span>


    <span class="k">def</span> <span class="nf">_compute_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the parameters `alpha` given the parameters `omega`.</span>

<span class="sd">        Cf. Table 4 in Rzhetsky et al., 2009.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
        <span class="n">nclasses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclasses</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,))</span>

        <span class="c"># ------ alpha_1,2,3</span>

        <span class="c"># sum over all doublets</span>
        <span class="n">outer_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
        <span class="n">sum_wi_wk</span> <span class="o">=</span>  <span class="n">outer_omega</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c"># sum over all omega_i * omega_j, where i!=k and j!=k</span>
        <span class="n">sum_wi_wj_not_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nclasses</span><span class="p">,))</span>
        <span class="c"># sum over all omega_i ** 2, where i!=k</span>
        <span class="n">sum_wi2_not_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nclasses</span><span class="p">,))</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="n">sum_wi_wj_not_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_wi_wk</span>
                                  <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">outer_omega</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                  <span class="o">+</span> <span class="n">outer_omega</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
            <span class="n">sum_wi2_not_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">outer_omega</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                <span class="o">-</span> <span class="n">outer_omega</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">sum_wi2_not_k</span> <span class="o">/</span> <span class="n">sum_wi_wj_not_k</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span>

        <span class="c"># ------ alpha_4,5,6,7</span>

        <span class="c"># sum over all triplets</span>
        <span class="n">outer_omega3</span> <span class="o">=</span> <span class="p">(</span><span class="n">outer_omega</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:])</span>
        <span class="n">sum_wi_wj_wl</span> <span class="o">=</span> <span class="n">outer_omega3</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c"># sum over omega_i * omega_j * omega_l, where i!=k and j!=k and l!=k</span>
        <span class="n">sum_wi_wj_wl_not_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nclasses</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="n">sum_wi_wj_wl_not_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_wi_wj_wl</span>
                                     <span class="o">-</span> <span class="mf">3.</span><span class="o">*</span><span class="n">outer_omega3</span><span class="p">[:,:,</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                     <span class="o">+</span> <span class="mf">3.</span><span class="o">*</span><span class="n">outer_omega3</span><span class="p">[:,</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                     <span class="o">-</span> <span class="n">outer_omega3</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
        <span class="n">omega3</span> <span class="o">=</span> <span class="n">omega</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">sum_wi3_not_k</span> <span class="o">=</span> <span class="n">omega3</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">omega3</span>

        <span class="n">a4</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">sum_wi3_not_k</span> <span class="o">/</span> <span class="n">sum_wi_wj_wl_not_k</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">alpha</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a4</span>

        <span class="n">a5</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclasses</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                        <span class="n">tmp</span> <span class="o">+=</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">a5</span> <span class="o">+=</span> <span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">sum_wi_wj_wl_not_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">alpha</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">a5</span>

        <span class="k">return</span> <span class="n">alpha</span>


    <span class="c">##### Verify input ########################################################</span>

<div class="viewcode-block" id="ModelA.are_annotations_compatible"><a class="viewcode-back" href="../../pyanno.models.html#pyanno.modelA.ModelA.are_annotations_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">are_annotations_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the annotations are compatible with the models&#39; parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">(</span><span class="n">ModelA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">are_annotations_compatible</span><span class="p">(</span><span class="n">annotations</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">masked_annotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">MISSING_VALUE</span><span class="p">)</span>

        <span class="c"># exactly 3 annotations per row</span>
        <span class="n">nvalid</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">masked_annotations</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nvalid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nannotators_per_item</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyanno 2.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Pietro Berkes, Bob Carpenter, Andrey Rzhetsky, James A. Evans.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>